<!DOCTYPE html>
<html lang="en">

<head>
    <title></title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="prism.css" rel="stylesheet">
    <link href="csss/slideshow.css" rel="stylesheet">
    <link href="csss/reusable.css" rel="stylesheet">
    <link href="style.css" rel="stylesheet">
</head>

<body class="language-js">
    <header class="slide title">
        <figure>
            <h1>Functional Programming</h1>
            <p class="tagline">Introducing to FP with js</p>
        </figure>
    </header>
    <section class="slide">
        <h1>Basic Definitions</h1>
        <p>Functional programming (often abbreviated FP) is the process of building software by composing pure functions, avoiding
            shared state, mutable data, and side-effects.</p>
        <p class="delayed">
            Functional programming is a programming paradigm. That means the way an application can be built and executed.
        </p>
        <p class="delayed">
            Itâ€™s the process of building software by composing pure functions, avoiding shared state, mutable data and side-effects.
        </p>
        <p class="delayed">
            It's declarative rather then imperative.
        </p>
    </section>
    <section class="slide">
        <h1>Advantages</h1>
        <figure>
            <h2>Concise</h2>
            <pre>
                <code>
const double = x => x * 2;
const trace = x => {console.log(x); return x;}
const doubleWithTrace = compose(double, trace);

const arr = [1, 2, 3];

const newArr = arr.map(doubleWithTrace); // 1, 2, 3

newArr; // [2, 4, 6];
                </code>
            </pre>
        </figure>
    </section>
    <section class="slide">
        <h1>Advantages</h1>
        <figure>
            <h2>Predictable</h2>
            <pre>
                <code>
const wrap = x => ({num: x});
const positive = x => x >= 0;

const arr1 = [1, -2, 3];
const arr2 = [...arr1];

arr1.filter(positive).map(wrap); // [{num: 1}, {num: 3}];
arr2.filter(positive).map(wrap); // [{num: 1}, {num: 3}];
                </code>
            </pre>
        </figure>
    </section>
    <section class="slide">
        <h1>Advantages</h1>
        <figure>
            <h2>Easier to test</h2>
            <pre>
                <code>
const total = (acc, cur) => acc += cur;
const average = arr => arr.reduce(0, total) / arr.length;

assert.equal(10, average([15, 10, 5]));
assert.equal(30, average([30]));
assert.equal(0, average([]));
                </code>
            </pre>
        </figure>
        <p class="delayed">
            Look, no boilerplate, no mocks.
        </p>
    </section>
    <section class="slide">
        <h1>Pure Functions</h1>
        <figure>
            <ul>
                <li>Given the same input always returns the same output</li>
                <li>Has no side-effects</li>
                <li>Referential transparency</li>
            </ul>
        </figure>
    </section>
    <section class="slide">
        <h1>Function Composition</h1>
        <p>Process of combining of several functions in order to produce a new function or to perform some computation</p>
        <pre>
            <code>
                const addOne = x => x + 1;
                const double = x => x * 2;
                const addOneAndDouble = x => double(addOne(x));

                const arr = [1, 2, 3];
                arr.map(addOneAndDouble); // [4, 6, 8]
            </code>
        </pre>
    </section>
    <section class="slide">
        <h1>Function Composition</h1>
        <p>Currying and partial application</p>
        <pre>
            <code>
                const f1 = (a, b, c) => a * b * c;
                f(1, 2, 3) // 6
                
                f2 = curry(f1); // Returns the curried function

                f2(1) // Returns function with partial application of 1 argument
                f2(1)(2) // Returns function with partial application of 2 arguments
                f2(1)(2)(3); // 6
            </code>
        </pre>
    </section>
    <section class="slide">
        <h1>Function Composition</h1>
        <p>Compose or pipe</p>
        <pre>
            <code>
                const names = ['John', 'James'];

                const addPrefix = (prefix, x) => `${prefix}-${x}`; //Some external 3d party function

                const toUpper = x => x.toUpperCase();
                const addPrefixCurried = curry(addPrefix);

                const processName = pipe(addPrefix('mr. '), toUpper); 

                names.map(processName); // ['MR. JOHN', 'MR. JAMES'];
            </code>
        </pre>
    </section>
    <section class="slide">
        <h1>Shared State</h1>
        <p>Any variable or object in a shared scope or being passed between scopes</p>
        <pre>
            <code>
                const foo = {
                    x: 1,
                    incr() {
                        this.x++;
                    }
                }

                const f = obj => obj.x *= 2;
            </code>
        </pre>
    </section>
    <section class="slide">
        <h1>Shared State</h1>
        <p>FP approach is to derive new data from existing instead of using shared state</p>
        <pre>
            <code>
                const arr1 = [1, 2, 3];
                const arr2 = arr1.map(x => x);

                arr1 === arr2; // false
            </code>
        </pre>
    </section>
    <section class="slide">
        <h1>Shared State</h1>
        <p>The problem with the shared state is the need to now every variable possible involved to predict the effect of a function.</p>
        <p>There are other effects known as 'Race condition' and 'Timing dependency'.</p>
        <pre>
            <code>
                const foo = {val: 3};
                const incr = () => foo.val += 1;
                const double = () => foo.val *= 2;

                incr();
                double(); // foo.val is 8

                double();
                incr(); // foo.val is 7

            </code>
        </pre>
    </section>
    <section class="slide">
        <h1>Shared State</h1>
        <p>With pure functions you always have the same output for the same input.</p>
        <p>Functions are completely independent from other functions calls.</p>
        <p>It can dramatically simplify refactoring and modifications.</p>
        <pre>
            <code>
                const foo = {val: 3};
                const incr = x => Object.assign({}, x, {val: x.val += 1});
                const double = x => Object.assign({}, x, {val: x.val *= 2});

                let boo = incr(double(foo)) // boo.val is 7

                let boo = double(incr(foo)) // boo.val is 8

            </code>
        </pre>
    </section>
    <script type="text/javascript" src="prism.js"></script>
    <script type="text/javascript" src="csss/slideshow.js"></script>
</body>

</html>